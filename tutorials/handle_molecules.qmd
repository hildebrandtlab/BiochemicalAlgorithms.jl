---
title: All on Handling molecules
engine: julia
---

```{julia}
#| echo: false
#| output: false

using BiochemicalAlgorithms
Base.active_module() = BiochemicalAlgorithms
```


## How can I create a simple molecule?
```{julia}
# create a system first
sys = System{Float32}() # this system will be of single precision, i.e., atom positions, velocities...

# as well as a molecule
h2o = Molecule(sys)

# create system atoms
o1 = Atom(h2o, 1, Elements.O)
h1 = Atom(h2o, 2, Elements.H)
h2 = Atom(h2o, 3, Elements.H)

# set positions of the atoms
# o1.r = [0, 0, 0]  <-- this is the default value!
h1.r = [1, 0, 0]
h2.r = [cos(deg2rad(105)), sin(deg2rad(105)), 0]

# add bonds
Bond(h2o, o1.idx, h1.idx, BondOrder.Single)
Bond(h2o, o1.idx, h2.idx, BondOrder.Single)

println("Number of atoms: ", natoms(h2o))
println("Number of bonds: ", nbonds(h2o))
```


## How can I determine the element of an atom (C, N, ...)?

```{julia}
sys = load_pdb(ball_data_path("../test/data/AlaAla.pdb"))
for atom in atoms(sys)
    println("Atom no.: $(atom.number), element: $(atom.element)")
end
```

You can also filter for specific elements:
```{julia}
c_atoms = filter(atom -> atom.element == Elements.C, atoms(sys))
for atom in c_atoms
    println("Atom no.: $(atom.number), element: $(atom.element)")
end
```


## How can I identify backbone atoms?
```{julia}
sys = load_pdb(ball_data_path("../test/data/AlaAla.pdb"))
for atom in atoms(sys)
    print(atom.element)
    if atom.name in ["C", "O", "N", "HA"]
        print(" <-- This is a backbone atom!")
    end
    println()
end
```


## How can I get the one-letter (or three-letter) code out of a pdb file?
```{julia}
sys = load_pdb(ball_data_path("../test/data/2ptc.pdb"))
for chain in chains(sys)
    # get all residues from the current chain
    res = residues(chain)
    println("> Chain $(chain.name)")
    println("One-letter code:")
    println(join(one_letter_code.(res.name), "")) 
    println("Three-letter code:")
    println(join(three_letter_code.(res), " ")) 
end
```


## How can I pick one single chain out of a system containing several chains?
This is often needed when a receptor and a ligand are co-complexed and you want to treat them separately.
```{julia} 
sys = load_pdb(ball_data_path("../test/data/2ptc.pdb"))

all_chains = chains(sys)
```

This snippet will create separate PDB files for the two chains of the system:
```{julia}
write_pdb("2ptc_chainE.pdb", all_chains[1])
write_pdb("2ptc_chainI.pdb", all_chains[2])
```


## How can I map two configurations of the same protein onto each other?

```{julia}
# read in the first protein
sys = load_pdb(ball_data_path("../test/data/2ptc.pdb"))
mol = first(molecules(sys))

# we will generate a second version of the protein by moving it around
sys2 = deepcopy(sys)
mol2 = first(molecules(sys2))
translate!(mol2, Vector3{Float32}(2.0,1.0,2.0))

# let's see how far the structures are apart
println("RMSD before mapping:\t", compute_rmsd(mol2, mol))

# now we have two proteins or system we can map together
map_rigid!(mol2, mol)

# let's see how far the structures are apart afterwards
println("RMSD after mapping:\t", compute_rmsd(mol2, mol))
```


## How can I rotate an entire molecule?
```{julia}
# read in the first protein
sys = load_pdb(ball_data_path("../test/data/2ptc.pdb"))
mol = first(molecules(sys))

v = Vector3{T}(0, 0, 0) # no translation
m = Matrix3{T}(1, 0, 0, 0, 0, -1, 0, 1, 0) # counter clockwise rotation by 90 degree
r = RigidTransform(m, v)

# perform the transformation
rigid_transform!(mol, r)

```


## How can I remove water molecules from a system?

```{julia}
sys = load_pdb(ball_data_path("../test/data/1tgh.pdb"))

println("Number of atoms before removing water: ", natoms(sys))

# find all water fragments
ft = filter(frag -> frag.name == "HOH", fragments(sys))

# delete the found fragments, including all atoms and bonds
delete!(ft)

println("Number of atoms after removing water: ", natoms(sys))
```


# How can I identify atoms in a certain spatial proximity efficiently?

Identifying atoms in a certain spatial proximity can be done with `CellListMap.jl` which is already a dependency of BiochemicalAlgorithms.jl. Here is an example with a cutoff distance of 1.5:
```{julia}
using CellListMap

sys = load_pdb(ball_data_path("../test/data/1tgh.pdb"))

neighbors = neighborlist([a.r for a in atoms(sys)], 1.5)

```

`neighborlist` returns a tuple consisting of indices for the neighbors and the computed distance between them. For more advanced use cases have a look at the [`CellListMap.jl` documentation](https://m3g.github.io/CellListMap.jl/stable/neighborlists/) . 