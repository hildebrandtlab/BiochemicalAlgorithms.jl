---
title: Getting started
engine: julia
---

BiochemicalAlgorithms.jl`s design is inspired by its predecessor [```BALL```](https://github.com/ball-project/ball). BALL and BiochemicalAlgorithms.jl both have a set of KERNEL classes or core classes to represent molecular entities such as Molecules, Proteins, Atoms, Bonds etc. The following class diagramm shows the different classes and their relationship to each others.

![UML class diagram *Note*: Only the most important functionalities are shown here.](uml.png)

In the center of all classes resides the ```System```. So let's see it in action with a simple peptide:
```{julia}
using BiochemicalAlgorithms

s = load_pdb(ball_data_path("../test/data/AlaAla.pdb"))
s
```

This will give us an overview of the objects associated with our system. It contains 23 atoms, 0 bonds, 1 molecule, 1 chain, 0 secondary structures and 2 fragments. We look at each group separately in the following sections.

If we do not explicitely create a system, the data will be stored in the default system:
```{julia}
load_pdb(ball_data_path("../test/data/AlaAla.pdb"))
```


## Atoms:

We can access the atoms like this:
```{julia}
sys_atms = atoms(s)

natoms(sys_atms)
```

Let's play around with it:
```{julia}
println("Atom elements:")
for a in sys_atms
    print(a.element)
end
println()

n1= atom_by_name(s, "N")

println(n1.idx)

```

We can access an atom by its name, which will return the first atom matching the given name. If there are more atoms with the same name and we are not interested in the first one, we can access the atom by the atom index.
The atom index is unique inside a system but not necessarily starting by one.

```{julia}
println("Atom ids:")
for a in sys_atms
    println(a.idx, " ", a.element)
end

n2 = atom_by_idx(sys, 17)

```

```Atom``` features the atom number as well. The atom number does NOT have to be unique inside the system!

```{julia}
for a in sys_atms
    println(a.idx, " ", a.number)
end
a = Atom(s, number = 7, element = Elements.N;)
```

Next, we will have a look at the fragments.

## Fragments:

Fragments represent molecule fragments. In context of proteins or nucleic acids, the fragment can be used to represent residue or nucleotide. See the documentation for the definition of the ```FragmentVariantType``` (https://hildebrandtlab.github.io/BiochemicalAlgorithms.jl/stable/public/system/#BiochemicalAlgorithms.FragmentVariant)

```{julia}
nfragments(s)

for frag in fragments(s)
    println(frag.name, " ", frag.idx)
end
n2 = atom_by_idx(s, 17)

println("The N atom belongs to residue: ", n2.fragment_idx)

```

We can get the fragment as well directly:
```{julia}
fragment = parent_fragment(n2)
println(fragment)
res2 = fragment_by_idx(s, 3)
```

Just like atom indices, fragment indices not necessarily follow a certain order but are unique inside the same system object.


```{julia}
res1 = fragments(s)[1]
res1.variant # 1 = unknown, 2 = residue, 3 = nucleotide
```

Alternatively, it is also possible to check if this is a nucleotide:

```{julia}
println(is_nucleotide(res1))

println("Number of fragments before push: ", nfragments(s))
push!(chain_by_idx(s, 2), res1)
println("Number of fragments after push: ", nfragments(s))
delete!(res1)
println("Number of fragments after deletion: ", nfragments(s))

for frag in fragments(s)
    println(frag.name, " ", frag.idx)
end
s
```

```{julia}
s = load_pdb(ball_data_path("../test/data/AlaAla.pdb")) # restore original data
println("is residue ", isresidue(res1))
```

